package com.example.wfc_models.shell

import com.example.wfc_models.dependencies.binary_dependencies.dtos.BinaryDependency
import com.example.wfc_models.exceptions.BusinessException
import com.example.wfc_models.shell.dtos.ShellSettings
import com.example.wfc_models.shell.root_logic.Shell
import com.example.wfc_models.shell.root_logic.Shell.Command.Result
import kotlinx.coroutines.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject

class ShellService @Inject constructor() : IShellService {
    private val _defaultTimeout = Shell.Timeout(30, TimeUnit.SECONDS)

    override fun executeCommandAsync(
        settings: ShellSettings,
        binaryDependency: BinaryDependency
    ): Deferred<Result> = CoroutineScope(Dispatchers.IO).async {
        val command = "${binaryDependency.localPath} ${settings.command}"

        val shellSettings = ShellSettings(
            shell = settings.shell,
            command = command,
            timeout = settings.timeout,
            onStdOutLineListener = settings.onStdOutLineListener
        )

        return@async executeCommandAsync(shellSettings).await()
    }

    override fun executeCommandAsync(settings: ShellSettings): Deferred<Result> =
        CoroutineScope(Dispatchers.IO).async {
            try {
                val executeTimeout = settings.timeout ?: _defaultTimeout

                val result = settings.shell.run(settings.command) {
                    timeout = executeTimeout
                    redirectErrorStream = false
                    onStdErr = settings.onStdOutLineListener ?: {}
                    onStdOut = settings.onStdOutLineListener ?: {}
                    notify = true
                }
                return@async result
            } catch (ex: Exception) {
                if (ex is CancellationException) {
                    settings.shell.interrupt()
                    throw ex
                }
                throw BusinessException(ex.message)
            }
        }

    override fun isRootAccessAllowedAsync(): Deferred<Boolean> = CoroutineScope(Dispatchers.IO).async {
        val shellSu = Shell.SU
        val permissionDeniedMessage = "Permission denied"

        val shellSettings = ShellSettings(
            shell = shellSu,
            command = "",
            timeout = Shell.Timeout(10, TimeUnit.SECONDS),
            onStdOutLineListener = { message -> if( message == permissionDeniedMessage) shellSu.interrupt() }
        )

        try {
            val result = executeCommandAsync(shellSettings).await()
            return@async result.isSuccess
        } catch (ex: Exception){
            return@async false;
        }
    }
}