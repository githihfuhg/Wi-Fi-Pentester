package com.example.wfc_models.shell

import com.example.wfc_models.dependencies.binary_dependencies.dtos.BinaryDependency
import com.example.wfc_models.exceptions.BusinessException
import com.example.wfc_models.shell.dtos.ShellSettings
import com.example.wfc_models.shell.dtos.ShellType
import com.example.wfc_models.shell.root_logic.Shell
import com.example.wfc_models.shell.root_logic.Shell.Command.Result
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.concurrent.TimeUnit
import javax.inject.Inject

class ShellService @Inject constructor() : IShellService {
    private val _defaultTimeout = Shell.Timeout(30, TimeUnit.SECONDS)

    override suspend fun executeCommand(
        command: String,
        settings: ShellSettings,
        onStdOutLineListener: ((result: String) -> Unit)?
    ): Result = coroutineScope {
        val shell = getShellByType(settings.shellType)

        val executeTimeout = when (settings.timeout) {
            null -> _defaultTimeout
            else -> Shell.Timeout(settings.timeout.value, settings.timeout.unit)
        }

        try {
            withContext(Dispatchers.IO) {
                val result = shell.run(command) {
                    timeout = executeTimeout
                    redirectErrorStream = true
                    onStdOut = onStdOutLineListener ?: {}
                    notify = true
                }
                return@withContext result
            }

        } catch (ex: Exception) {
            if (ex is CancellationException) {
                shell.interrupt()
                throw ex
            }
            throw BusinessException(ex.message)
        }
    }

    override suspend fun executeCommandFlow(
        command: String,
        settings: ShellSettings
    ): Flow<String> = callbackFlow {
        executeCommand(
            command = command,
            settings = settings,
            onStdOutLineListener = {
                trySend(it)
            }
        )
        awaitClose { cancel() }
    }

    private fun getShellByType(shellType: ShellType): Shell = when (shellType) {
        ShellType.SH -> Shell.SH
        ShellType.SU -> Shell.SU
    }

    override suspend fun executeCommand(
        command: String,
        settings: ShellSettings,
        binaryDependency: BinaryDependency,
        onStdOutLineListener: ((result: String) -> Unit)?
    ): Result = coroutineScope {
        val fullCommand = "${binaryDependency.localPath} $command"

        val shellSettings = ShellSettings(
            shellType = settings.shellType,
            timeout = settings.timeout,
        )

        return@coroutineScope executeCommand(fullCommand, shellSettings, onStdOutLineListener)
    }

    override suspend fun executeCommandFlow(
        command: String,
        settings: ShellSettings,
        binaryDependency: BinaryDependency
    ): Flow<String> = callbackFlow {
        executeCommand(
            command = command,
            settings = settings,
            binaryDependency = binaryDependency,
            onStdOutLineListener = {
                trySend(it)
            }
        )
        awaitClose { cancel() }
    }
}