package com.example.wfc_models.shell
import com.example.wfc_models.dependencies.binary_dependencies.data_models.BinaryDependencyType
import com.example.wfc_models.exceptions.BusinessException
import com.example.wfc_models.settings.data_models.AppSettings
import com.example.wfc_models.shell.data_models.ShellSettings
import com.example.wfc_models.shell.root_logic.Shell
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import java.util.concurrent.TimeUnit
import javax.inject.Inject

class SpecificShellCommandService @Inject constructor(
    private val _shellModel: IShellService,
) : ISpecificShellCommandService {
    override fun isDisableWiFiBeforeConnectionAsync(
        wifiInterfaceName: String,
        appSettings: AppSettings
    ): Deferred<Boolean?> = CoroutineScope(Dispatchers.IO).async {
        val iwDependency = appSettings.dependencies[BinaryDependencyType.IW]
            ?: throw throw BusinessException("iw dependency not found")

        val timeout = Shell.Timeout(2, TimeUnit.SECONDS)

        val wifiDisableSettings = ShellSettings(Shell.SU, "svc wifi disable", timeout)
        val wifiEnabledSettings = ShellSettings(Shell.SU, "svc wifi enable", timeout)
        val checkDisableWiFiBeforeConnectionSettings = ShellSettings(Shell.SU, "dev", timeout)

        _shellModel.executeCommandAsync(wifiDisableSettings).await()

        val shellResult = _shellModel
            .executeCommandAsync(checkDisableWiFiBeforeConnectionSettings, iwDependency)
            .await()

        if (!shellResult.isSuccess || !shellResult.stdout.any()) return@async null

        val isDisableWiFiBeforeConnection =
            shellResult.stdout.any { x -> x.contains(wifiInterfaceName) }

        _shellModel.executeCommandAsync(wifiEnabledSettings).await()

        return@async isDisableWiFiBeforeConnection
    }

    override fun checkSystemTypeAsync(): Deferred<AppSettings.SystemType> = CoroutineScope(
        Dispatchers.IO).async {
        val x64SystemPatterns = listOf("64","v8")
        val commandForCheckSystemType = "uname -m"

        val shellSettings = ShellSettings(Shell.SH, commandForCheckSystemType, Shell.Timeout(3, TimeUnit.SECONDS))

        val shellResult = _shellModel
            .executeCommandAsync(shellSettings)
            .await()

        if(!shellResult.isSuccess) return@async AppSettings.SystemType.X32

        val systemType = shellResult.stdout.first()

        val is64BitSystem = x64SystemPatterns.any{ x -> systemType.contains(x, true) }

        return@async if(is64BitSystem) AppSettings.SystemType.X64 else AppSettings.SystemType.X32
    }
}