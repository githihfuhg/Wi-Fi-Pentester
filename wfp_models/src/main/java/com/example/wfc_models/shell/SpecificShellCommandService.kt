package com.example.wfc_models.shell

import com.example.wfc_models.dependencies.binary_dependencies.dtos.BinaryDependencyType
import com.example.wfc_models.exceptions.BusinessException
import com.example.wfc_models.settings.dtos.AppSetting
import com.example.wfc_models.shell.dtos.ShellSettings
import com.example.wfc_models.shell.dtos.ShellTimeout
import com.example.wfc_models.shell.dtos.ShellType
import kotlinx.coroutines.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject

class SpecificShellCommandService @Inject constructor(
    private val _shellService: IShellService,
) : ISpecificShellCommandService {
    override suspend fun isDisableWiFiBeforeConnectionAsync(
        wifiInterfaceName: String,
        appSettings: AppSetting
    ): Boolean = coroutineScope {
        val iwDependency = appSettings.dependencies[BinaryDependencyType.IW]
            ?: throw throw BusinessException("iw dependency not found")

        val shellSettings = ShellSettings(
            shellType = ShellType.SU,
            timeout = ShellTimeout(2, TimeUnit.SECONDS)
        )

        _shellService.executeCommand("svc wifi disable", shellSettings)

        val shellResult = _shellService
            .executeCommand("dev", shellSettings, iwDependency, null)

        val isDisableWiFiBeforeConnection =
            shellResult.stdout.any { x -> x.contains(wifiInterfaceName) }

        _shellService.executeCommand("svc wifi enable", shellSettings)

        return@coroutineScope isDisableWiFiBeforeConnection
    }

    override suspend fun checkSystemTypeAsync(): AppSetting.SystemType = coroutineScope {
        val x64SystemPatterns = listOf("64", "v8")

        val shellSettings = ShellSettings(
            shellType = ShellType.SH,
            timeout = ShellTimeout(3, TimeUnit.SECONDS)
        )

        val shellResult = _shellService
            .executeCommand("uname -m", shellSettings)

        if (!shellResult.isSuccess) return@coroutineScope AppSetting.SystemType.X32

        val systemType = shellResult.stdout.first()

        val is64BitSystem = x64SystemPatterns.any { x -> systemType.contains(x, true) }

        return@coroutineScope if (is64BitSystem) AppSetting.SystemType.X64 else AppSetting.SystemType.X32
    }

    override suspend fun isRootAccessAllowedAsync(): Boolean = coroutineScope {
        val permissionDeniedMessage = "Permission denied"

        val shellSettings = ShellSettings(
            shellType = ShellType.SU,
            timeout = ShellTimeout(10, TimeUnit.SECONDS),
        )

        try {
            val commandResult = _shellService
                .executeCommand(command = "", settings = shellSettings)

            val result = commandResult.isSuccess &&
                    commandResult.output.all { it != permissionDeniedMessage }

            return@coroutineScope result
        } catch (ex: Exception) {
            return@coroutineScope false
        }
    }
}