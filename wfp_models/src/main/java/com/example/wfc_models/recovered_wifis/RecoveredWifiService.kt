package com.example.wfc_models.recovered_wifis

import android.os.Build
import com.example.wfc_data.database.WFCDatabase
import com.example.wfc_models.recovered_wifis.dtos.RecoveredWifi
import com.example.wfc_models.settings.ISettingsService
import com.example.wfc_models.settings.dtos.AppSetting
import com.example.wfc_models.shell.IShellService
import com.example.wfc_models.shell.dtos.ShellSettings
import com.example.wfc_models.shell.dtos.ShellType
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import org.w3c.dom.NodeList
import java.util.regex.Pattern
import javax.inject.Inject
import javax.xml.parsers.DocumentBuilderFactory

class RecoveredWifiService @Inject constructor(
    private val _database: WFCDatabase,
    private val _settingsModel: ISettingsService,
    private val _shellModel: IShellService
) : IRecoveredWifiService {

    override suspend fun getRecoveredWiFis(): List<RecoveredWifi> = coroutineScope {
        val recoveredWiFis = readFromDatabase()
        val appShellSettings = _settingsModel.getSetting(AppSetting::class.java)

        if (appShellSettings == null || !appShellSettings.isRootAccessAllowed)
            return@coroutineScope recoveredWiFis

        withContext(Dispatchers.IO) {
            val recoveredWiFisFromFile =
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) readFromWifiConfigStore()
                else readFromWpaSupplicantConfig()

            return@withContext recoveredWiFis
                .union(recoveredWiFisFromFile)
                .toList()
        }
    }

    private suspend fun readFromDatabase(): List<RecoveredWifi> = coroutineScope() {
        return@coroutineScope _database
            .wiFiDao()
            .getWithPassword()
            .map { x -> RecoveredWifi(x.name, x.mac, x.password!!) }
    }

    private suspend fun readFromWpaSupplicantConfig(): List<RecoveredWifi> = coroutineScope {
        val recoveredWiFis = mutableListOf<RecoveredWifi>()

        val wifiConfigPath = "/data/misc/wifi/wpa_supplicant.conf"

        val wifiConfigStr = readConfig(wifiConfigPath)
            ?: return@coroutineScope recoveredWiFis

        val networkPattern = Pattern.compile("(?<=network=\\{\n)((.+)\n)+(?=})")

        val matchNetwork = networkPattern.matcher(wifiConfigStr)
        while (matchNetwork.find()) {
            val network = matchNetwork.group()

            val nameMather = Pattern.compile("(?<=ssid=\")(.+)+(?=\")").matcher(network)
            val macMather = Pattern.compile("(?<=bssid=)\\w{2}:\\w{2}:\\w{2}:\\w{2}:\\w{2}:\\w{2}")
                .matcher(network)
            val passwordMather = Pattern.compile("(?<=psk=\")(.+)+(?=\")").matcher(network)

            if (!passwordMather.find() || (!nameMather.find() && !macMather.find())) continue

            val name = nameMather.group() ?: ""
            val mac = macMather.group() ?: ""
            val password = passwordMather.group() ?: ""

            recoveredWiFis.add(RecoveredWifi(name, mac, password))
        }

        return@coroutineScope recoveredWiFis
    }

    private suspend fun readFromWifiConfigStore(): List<RecoveredWifi> = coroutineScope {
        val recoveredWiFis =
            mutableListOf<RecoveredWifi>()

        val wifiConfigPath = "/data/misc/wifi/WifiConfigStore.xml"
        val wifiConfigStr = readConfig(wifiConfigPath) ?: return@coroutineScope recoveredWiFis

        var wifiConfigurationNodes: NodeList

        wifiConfigStr.byteInputStream().use {
            val xmlDocument =
                DocumentBuilderFactory
                    .newInstance()
                    .newDocumentBuilder()
                    .parse(it)

            wifiConfigurationNodes = xmlDocument.getElementsByTagName("WifiConfiguration")
        }

        val ssid = "SSID"
        val preSharedKey = "PreSharedKey"
        val randomizedMacAddress = "RandomizedMacAddress"

        for (i in 0 until wifiConfigurationNodes.length) {
            val propertyNodes = wifiConfigurationNodes.item(i).childNodes

            var name = null as String?
            var mac = null as String?
            var password = null as String?
            for (j in 0 until propertyNodes.length) {
                val propertyNode = propertyNodes.item(j)

                if (propertyNode.attributes.length == 0 || propertyNode.childNodes.length == 0) continue

                val attributeValue =
                    propertyNode.attributes.item(0).nodeValue?.toString() ?: continue
                val propertyValue = propertyNode.childNodes.item(0).nodeValue?.toString()

                when (attributeValue) {
                    ssid -> name = propertyValue?.removePrefix("\"")?.removeSuffix("\"")
                    randomizedMacAddress -> mac = propertyValue
                    preSharedKey -> password = propertyValue?.removePrefix("\"")?.removeSuffix("\"")
                }
            }

            if (password.isNullOrEmpty() || (name.isNullOrEmpty() && mac.isNullOrEmpty())) continue

            recoveredWiFis.add(RecoveredWifi(name ?: "", mac ?: "", password))
        }

        return@coroutineScope recoveredWiFis
    }

    private suspend fun readConfig(path: String): String? = coroutineScope {
        val shellSettings = ShellSettings(ShellType.SU)
        val shellResult = _shellModel.executeCommand("cat $path", shellSettings, null)

        return@coroutineScope if (shellResult.isSuccess) shellResult.stdout.joinToString("") else null
    }
}
