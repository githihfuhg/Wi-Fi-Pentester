package com.example.wfc_models.recovered_wifis
import android.os.Build
import com.example.wfc_data.database.WFCDatabase
import com.example.wfc_models.recovered_wifis.data_models.RecoveredWifi
import com.example.wfc_models.settings.ISettingsService
import com.example.wfc_models.settings.data_models.AppSettings
import com.example.wfc_models.shell.IShellService
import com.example.wfc_models.shell.data_models.ShellSettings
import com.example.wfc_models.shell.root_logic.Shell
import kotlinx.coroutines.*
import org.w3c.dom.NodeList
import java.util.regex.Pattern
import javax.inject.Inject
import javax.xml.parsers.DocumentBuilderFactory

class RecoveredWifiService @Inject constructor(
    private val _database: WFCDatabase,
    private val _settingsModel: ISettingsService,
    private val _shellModel: IShellService
    ) : IRecoveredWifiService {

    override suspend fun getRecoveredWiFis(): List<RecoveredWifi> = coroutineScope {
        val recoveredWiFis = readFromDatabase()
        val appShellSettings = _settingsModel.getSettings(AppSettings::class.java)

        if(appShellSettings == null || !appShellSettings.isRootAccessAllowed)
            return@coroutineScope recoveredWiFis

        val recoveredWiFisFromFile =
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) readFromWifiConfigStore()
            else readFromWpaSupplicantConfig()

        return@coroutineScope recoveredWiFis
            .union(recoveredWiFisFromFile)
            .toList()
    }

    private suspend fun readFromDatabase():List<RecoveredWifi> = coroutineScope {
        return@coroutineScope _database
            .wiFiDao()
            .getWithPassword()
            .map { x -> RecoveredWifi(x.name, x.mac, x.password!!) }
    }

    private suspend fun readFromWpaSupplicantConfig(): List<RecoveredWifi> = coroutineScope {
        val recoveredWiFis= mutableListOf<RecoveredWifi>()

        val wifiConfigPath = "/data/misc/wifi/wpa_supplicant.conf"

        val wifiConfigStr = readConfig(wifiConfigPath)
            ?: return@coroutineScope recoveredWiFis

        val networkPattern = Pattern.compile("(?<=network=\\{\n)((.+)\n)+(?=})")

        val matchNetwork = networkPattern.matcher(wifiConfigStr)
        while (matchNetwork.find()) {
            val network = matchNetwork.group()

            val nameMather = Pattern.compile("(?<=ssid=\")(.+)+(?=\")").matcher(network)
            val macMather = Pattern.compile("(?<=bssid=)\\w{2}:\\w{2}:\\w{2}:\\w{2}:\\w{2}:\\w{2}").matcher(network)
            val passwordMather = Pattern.compile("(?<=psk=\")(.+)+(?=\")").matcher(network)

            if (!passwordMather.find() || (!nameMather.find() && !macMather.find())) continue

            val name = nameMather.group() ?: ""
            val mac = macMather.group() ?: ""
            val password = passwordMather.group() ?: ""

            recoveredWiFis.add(RecoveredWifi(name, mac, password))
        }

        return@coroutineScope recoveredWiFis
    }

    private suspend fun readFromWifiConfigStore(): List<RecoveredWifi> = coroutineScope {
        val recoveredWiFis =
            mutableListOf<RecoveredWifi>()

        val wifiConfigPath = "/data/misc/wifi/WifiConfigStore.xml"
        val wifiConfigStr = readConfig(wifiConfigPath) ?: return@coroutineScope recoveredWiFis

        var wifiConfigurationNodes: NodeList

        wifiConfigStr.byteInputStream().use {
            val parseDocumentJob = async(Dispatchers.IO) {
                DocumentBuilderFactory
                    .newInstance()
                    .newDocumentBuilder()
                    .parse(it)
            }
            val xmlDocument = parseDocumentJob.await()

            wifiConfigurationNodes = xmlDocument.getElementsByTagName("WifiConfiguration")
        }

        val ssid = "SSID"
        val preSharedKey = "PreSharedKey"
        val randomizedMacAddress = "RandomizedMacAddress"

        for(i in 0 until wifiConfigurationNodes.length) {
            val propertyNodes = wifiConfigurationNodes.item(i).childNodes

            var name = null as String?
            var mac = null as String?
            var password = null as String?
            for (j in 0 until propertyNodes.length) {
                val propertyNode = propertyNodes.item(j)

                if(propertyNode.attributes.length == 0 || propertyNode.childNodes.length == 0) continue

                val attributeValue = propertyNode.attributes.item(0).nodeValue?.toString() ?: continue
                val propertyValue = propertyNode.childNodes.item(0).nodeValue?.toString()

                when(attributeValue) {
                    ssid -> name = propertyValue?.removePrefix("\"")?.removeSuffix("\"")
                    randomizedMacAddress -> mac = propertyValue
                    preSharedKey -> password = propertyValue?.removePrefix("\"")?.removeSuffix("\"")
                }
            }

            if(password.isNullOrEmpty() || (name.isNullOrEmpty() && mac.isNullOrEmpty())) continue

            recoveredWiFis.add(RecoveredWifi(name ?: "", mac ?: "", password))
        }

        return@coroutineScope recoveredWiFis
    }

    private suspend fun readConfig(path: String) : String? = coroutineScope {
        val shellSettings = ShellSettings(Shell.SU, "cat $path")
        val shellResult = _shellModel.executeCommandAsync(shellSettings).await()

        return@coroutineScope if (shellResult.isSuccess) shellResult.stdout.joinToString("") else null
    }
}
