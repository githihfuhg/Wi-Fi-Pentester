package com.example.wfc_models.wifi.scanners

import com.example.wfc_models.exceptions.BusinessException
import com.example.wfc_models.settings.ISettingsService
import com.example.wfc_models.settings.dtos.WifiFilter
import com.example.wfc_models.settings.dtos.WifiScannerSetting
import com.example.wfc_models.settings.dtos.WifiSortMode
import com.example.wfc_models.wifi.scanners.contracts.IRootWifiScanner
import com.example.wfc_models.wifi.scanners.contracts.IWifiScanService
import com.example.wfc_models.wifi.scanners.contracts.IWifiScanner
import com.example.wfc_models.wifi.scanners.dtos.Wifi
import com.example.wfc_models.wifi.scanners.dtos.WifiScannerState
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class WifiScanService @Inject constructor(
    private val _wifiScanner: IWifiScanner,
    private val _rootWifiScanner: IRootWifiScanner,
    private val _settingsModel: ISettingsService,
) : IWifiScanService {
    private val _mutableWifiList = MutableSharedFlow<List<Wifi>>()
    private var _wifiScanningJob: Job? = null

    override val wifiList = _mutableWifiList as SharedFlow<List<Wifi>>
    override val scannerState: WifiScannerState
        get() {
            return if (_wifiScanningJob == null) WifiScannerState.DISABLED
            else WifiScannerState.ENABLED
        }

    override suspend fun startScan(wifiScannerCustomSettings: WifiScannerSetting?) =
        coroutineScope {
            if (scannerState == WifiScannerState.ENABLED) return@coroutineScope

            val wifiScannerSettings =
                wifiScannerCustomSettings
                    ?: _settingsModel.getSetting(WifiScannerSetting::class.java)
                    ?: throw BusinessException("Wifi scanner settings not found")

            val currentWifiScanner =
                if (wifiScannerSettings.isRootMode) _rootWifiScanner
                else _wifiScanner

            val delayInMilliseconds = (wifiScannerSettings.timeoutInSeconds * 1000).toLong()

            _wifiScanningJob = launch {
                while (coroutineContext.isActive) {
                    var resultWifiList = currentWifiScanner.scanAsync()
                    resultWifiList = filterWifiList(resultWifiList, wifiScannerSettings.filters)
                    resultWifiList = sortWifiList(resultWifiList, wifiScannerSettings.sortMode)

                    _mutableWifiList.emit(resultWifiList)
                    delay(delayInMilliseconds)
                }
            }
        }

    override suspend fun stopScan() = coroutineScope {
        if (scannerState == WifiScannerState.DISABLED) return@coroutineScope

        _wifiScanningJob?.cancelAndJoin()
        _wifiScanningJob = null
    }

    private fun filterWifiList(wifiList: List<Wifi>, filters: List<WifiFilter>): List<Wifi> {
        val result = wifiList.filter { wifi ->
            val isSuitableValue = filters.all { x ->
                val getFieldValueFunc =
                    _getPropertyValueFunctionsByName[x.fieldName] ?: return@all false
                val fieldValue = getFieldValueFunc(wifi)
                return@all fieldValue.toString() == x.fieldValue
            }
            return@filter isSuitableValue
        }

        return result
    }

    private val _getPropertyValueFunctionsByName = hashMapOf<String, (wifi: Wifi) -> Any>(
        Wifi::name.name to { it.name },
        Wifi::mac.name to { it.mac },
        Wifi::signalLevel.name to { it.signalLevel },
        Wifi::isConnected.name to { it.isConnected },
        Wifi::frequency.name to { it.frequency },
        Wifi::channel.name to { it.channel },
        Wifi::hasWps.name to { it.hasWps },
        Wifi::encryptionType.name to { it.encryptionType },
        Wifi::vendorName.name to { it.vendorName },
        Wifi::distance.name to { it.distance },
        Wifi::frequencyType.name to { it.frequencyType },
    )

    private fun sortWifiList(wifiList: List<Wifi>, sortMode: WifiSortMode): List<Wifi> {
        return when (sortMode) {
            WifiSortMode.SIGNAL_LEVEL -> wifiList.sortedByDescending { x -> x.signalLevel }
            WifiSortMode.CHANNEL -> wifiList.sortedBy { x -> x.channel }
            WifiSortMode.NAME -> wifiList.sortedBy { x -> x.name }
            WifiSortMode.PROVIDER_NAME -> wifiList.sortedBy { x -> x.vendorName }
        }
    }
}