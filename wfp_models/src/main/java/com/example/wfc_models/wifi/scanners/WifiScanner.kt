package com.example.wfc_models.wifi.scanners

import android.annotation.SuppressLint
import android.net.wifi.WifiManager
import com.example.wfc_data.database.channles.repositories.IChannelsRepository
import com.example.wfc_data.database.providers.ProviderEntity
import com.example.wfc_data.database.providers.repositories.IProvidersRepository
import com.example.wfc_models.wifi.scanners.contracts.IWifiScanner
import com.example.wfc_models.wifi.scanners.dtos.EncryptionType
import com.example.wfc_models.wifi.scanners.dtos.Wifi
import kotlinx.coroutines.coroutineScope
import javax.inject.Inject

class WifiScanner @Inject constructor(
    private val _wifiManager: WifiManager,
    private val _channelsRepository: IChannelsRepository,
    private val _providersRepository: IProvidersRepository
) : IWifiScanner {

    @SuppressLint("MissingPermission")
    override suspend fun scanAsync() = coroutineScope {
        _wifiManager.startScan()

        val scanResults = _wifiManager.scanResults
        val connectionInfo = _wifiManager.connectionInfo
        val resultWifis = mutableListOf<Wifi>()
        val channelsByFrequency = _channelsRepository.getAllByFrequencyAsync()

        for (scanResult in scanResults) {
            val hasWps = scanResult.capabilities.contains("WPS")
            val encryptionType = parseEncryptionType(scanResult.capabilities)
            val wifiProvider = getWifiProviderAsync(scanResult.BSSID)
            val wifiChannel = channelsByFrequency[scanResult.frequency]

            val wifi = Wifi(
                name = scanResult.SSID,
                mac = scanResult.BSSID,
                signalLevel = scanResult.level,
                isConnected = scanResult.BSSID == connectionInfo.bssid,
                frequency = scanResult.frequency,
                channel = wifiChannel?.value ?: 0,
                hasWps = hasWps,
                encryptionType = encryptionType,
                vendorName = wifiProvider?.name ?: "Unknown"
            )
            resultWifis.add(wifi)
        }
        return@coroutineScope resultWifis
    }

    private suspend fun getWifiProviderAsync(bssid: String): ProviderEntity? = coroutineScope {
        val regex = Regex("^([a-z0-9]{2}:[a-z0-9]{2}:[a-z0-9]{2})")
        val mathResult = regex.find(bssid)
        val macPattern = mathResult?.groups?.get(1)?.value

        val wifiProvider =
            if (macPattern == null) null
            else _providersRepository.getAsync(macPattern)

        return@coroutineScope wifiProvider
    }

    private fun parseEncryptionType(capabilities: String): EncryptionType = with(capabilities) {
        when {
            contains(EncryptionType.WEP.value) -> EncryptionType.WEP
            contains(EncryptionType.WPA2.value) -> EncryptionType.WPA2
            contains(EncryptionType.WPA3.value) -> EncryptionType.WPA3
            contains(EncryptionType.WPA.value) -> EncryptionType.WPA
            else -> EncryptionType.OPEN
        }
    }
}