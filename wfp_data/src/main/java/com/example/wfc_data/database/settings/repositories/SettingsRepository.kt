package com.example.wfc_data.database.settings.repositories

import com.example.wfc_data.database.WFCDatabase
import com.example.wfc_data.database.caching.CacheEventType
import com.example.wfc_data.database.caching.IMemoryCache
import com.example.wfc_data.database.settings.SettingEntity
import com.example.wfc_data.database.settings.SettingsType
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.withContext
import javax.inject.Inject

class SettingsRepository @Inject constructor(
    database: WFCDatabase,
    private val _memoryCache: IMemoryCache
) : ISettingsRepository {
    private val _settingsDao = database.settingsDao()

    override fun getSettingFlow(settingsType: SettingsType): Flow<SettingEntity> {
        val key = getMemoryCacheKey(settingsType)
        val cachedSetting = _memoryCache.get<SettingEntity>(key)
        if (cachedSetting != null) {
            val settingFlow = _memoryCache.events
                .filter { it.key == key
                        && it.cacheEventType != CacheEventType.DELETED
                        && it.value is SettingEntity }
                .map { it.value as SettingEntity }

            return merge(settingFlow, flowOf(cachedSetting))
        }

        return _settingsDao.getSettingsFlow(settingsType)
            .distinctUntilChanged()
            .map { x ->
                _memoryCache.addOrUpdate(x, key)
                return@map x
            }
    }

    override suspend fun getSettingAsync(settingsType: SettingsType): SettingEntity? = coroutineScope {
        val key = getMemoryCacheKey(settingsType)

        val cachedSetting = _memoryCache.get<SettingEntity>(key)
        if (cachedSetting != null) {
            return@coroutineScope cachedSetting
        }

        withContext(Dispatchers.IO) {
            val setting = _settingsDao.getSetting(settingsType)
            if (setting != null) {
                _memoryCache.addOrUpdate(setting, key)
            }

            return@withContext setting
        }
    }

    override suspend fun createAsync(settingEntity: SettingEntity): Unit = coroutineScope {
        withContext(Dispatchers.IO) {
            _settingsDao.insert(settingEntity)
        }

        val key = getMemoryCacheKey(settingEntity.settingsId)
        _memoryCache.addOrUpdate(settingEntity, key)
    }

    override suspend fun updateAsync(settingEntity: SettingEntity): Unit = coroutineScope {
        withContext(Dispatchers.IO) {
            _settingsDao.update(settingEntity)
        }

        val key = getMemoryCacheKey(settingEntity.settingsId)
        _memoryCache.addOrUpdate(settingEntity, key)
    }

    private fun getMemoryCacheKey(settingsType: SettingsType): String {
        return "setting_${settingsType}"
    }
}