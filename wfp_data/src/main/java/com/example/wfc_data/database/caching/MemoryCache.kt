package com.example.wfc_data.database.caching

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import java.util.concurrent.ConcurrentHashMap
import javax.inject.Inject

@Suppress("UNCHECKED_CAST")
class MemoryCache @Inject constructor() : IMemoryCache {
    private val _events = MutableSharedFlow<CacheEvent>()
    private val _cachedItems = ConcurrentHashMap<String, Any>()

    override val events = _events as SharedFlow<CacheEvent>

    override fun <T> get(key: String): T? {
        val result = _cachedItems[key] as? T

        return result
    }

    override suspend fun addOrUpdate(item: Any, key: String): Boolean = coroutineScope {
        val exitsItem = _cachedItems[key]

        if (item == exitsItem) {
            return@coroutineScope false
        }

        val isUpdate = exitsItem != null
        val cacheEventType = if (isUpdate) {
            CacheEventType.UPDATED
        } else {
            CacheEventType.ADDED
        }

        _cachedItems[key] = item
        _events.emit(CacheEvent(key = key, value = item, cacheEventType))

        return@coroutineScope true
    }

    override suspend fun remove(key: String): Boolean = coroutineScope {
        val removedItem = _cachedItems.remove(key)
        val isSuccess = removedItem != null

        if (isSuccess) {
            _events.emit(CacheEvent(key = key, value = removedItem!!, CacheEventType.DELETED))
        }

        return@coroutineScope isSuccess
    }

    override suspend fun removeByType(type: Class<*>) {
        val keys = _cachedItems.entries
            .filter { it.value::class.java == type }
            .map { it.key }

        keys.forEach { _cachedItems.remove(it) }
    }
}